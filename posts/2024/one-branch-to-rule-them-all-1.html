<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automation Unbound | too long; automated</title>
    <link rel="icon" type="image/png" href="../../assets/logo-dark.png">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/light-theme.css">
    <link rel="stylesheet" href="../../styles/dark-theme.css">
    <link rel="stylesheet" href="../../styles/mobile.css">
    <link rel="stylesheet" href="../../highlight/styles/stackoverflow-light.min.css" class="theme-specific"
        data-theme="light">
    <link rel="stylesheet" href="../../highlight/styles/stackoverflow-dark.min.css" class="theme-specific"
        data-theme="dark">
</head>

<body>
    <div class="progress-container">
        <div class="progress-bar" id="myBar"></div>
    </div>
    <nav>
        <div class="nav-container">
            <a href="../../index.html" class="nav-logo">
                <img src="../../assets/logo-dark.png" class="logo-image">
                <span class="site-title">too long; automated</span>
            </a>
            <ul class="nav-links">
                <li><a href="../../index.html" style="border-bottom: none;">home</a></li>
                <!-- <li><a href="../../links.html">Links</a></li> -->
                <li><a href="../../archive.html" style="border-bottom: none;">archive</a></li>
                <!-- <li><a href="../../about.html">About</a></li> -->
            </ul>
            <ul class="nav-theme-toggles">
                <li>
                    <button class="theme-toggle" data-theme="light" title="Light theme">â˜€ï¸</button>
                    <button class="theme-toggle" data-theme="dark" title="Dark theme">ğŸŒ™</button>
                    <button class="theme-toggle" data-theme="system" title="System theme">ğŸ’»</button>
                </li>
            </ul>
        </div>
    </nav>

    <main>
        <figure class="article-internal-image">
            <img src="2/image-wide.png" alt="One branch to rule them all, part 1.">
        </figure>

        <h1>one branch to rule them all | guided series #1</h1>

        <p class="article-subtitle">
            A lot of us deploy our apps to multiple cloud environments (or soon
            will). When I had to do that myself, I faced many questions, with
            the main one being: where do I even start? Let me show you.
        </p>

        <div class="article-meta">November 13, 2024</div>

        <div class="content-separator"></div>

        <p>
            Hey buddy, glad youâ€™re here! ğŸ‘‹ğŸ¼
        </p>

        <p>
            My goal for this short series is very simple: teach you by example.
            Together, weâ€™ll go through a full process I follow to solve various
            problems:
        </p>

        <ul class="article-list" style="list-style: none;">
            <li>ğŸ” <b>gather and understand requirements</b></li>
            <li>ğŸ§  <b>brainstorm solutions</b></li>
            <li>ğŸ¯ <b>scope</b></li>
            <li>ğŸ‘¨ğŸ»â€ğŸ’» <b>implement & test</b> (iterate until convergence)</li>
            <li>ğŸ›‘ <b>stop</b> (sounds easy? :p)</li>
        </ul>

        <p>
            Today, Iâ€™ll describe the first two stagesâ€“weâ€™ll gather and understand
            the requirements, and brainstorm various solutions. Next time, weâ€™ll
            implement some of them.
        </p>

        <p>
            What will we be working on this series?
        </p>

        <div class="key-concept">
            ğŸ¤” <b>PROBLEM DEFINITION</b>
            <br>
            How to deploy an app to multiple environments
            so that each env can run a different version of the application?
        </div>


        <p>
            Roll up your sleeves, itâ€™ll be fun!
        </p>

        <figure class="article-internal-gif">
            <img src="2/roll-up-your-sleeves.gif" alt="Roll up your sleeves!" style="width: 100%; height: auto;">
            <figcaption style="text-align: center;">Source: <a
                    href="https://tenor.com/pl/view/ready-good-up-gif-5210786">tenor.com</a>
            </figcaption>
        </figure>

        <div class="table-of-contents">
            <div class="toc-title">table of contents</div>
            <pre>
<span class="ascii">.</span>
<span class="ascii">â”œâ”€â”€ </span><a href="#gather-and-understand-requirements">ğŸ” Gather and understand requirements</a>
<span class="ascii">â”‚</span>
<span class="ascii">â””â”€â”€ </span><a href="#brainstorm-solutions">ğŸ§  Brainstorm solutions</a>
     |   <span class="ascii"></span>
     <span class="ascii">â”œâ”€â”€ </span><a href="#req-1-no-brainer-git-flow">ğŸ“‹ req #1: No-brainer git flow</a>
     |   <span class="ascii"> |</span>
     â”‚   <span class="ascii"> â”œâ”€â”€ </span><a href="#option-1-pure-trunk-based-development">ğŸ‘‰ option #1: pure trunk-based development</a>
     â”‚   <span class="ascii"> â”œâ”€â”€ </span><a href="#option-2-permissive-trunk-based-development">ğŸ‘‰ option #2: permissive trunk-based development</a>
     â”‚   <span class="ascii"> â””â”€â”€ </span><a href="#option-3-git-flow">ğŸ‘‰ option #3: git-flow</a>
     |   <span class="ascii"></span>
     <span class="ascii">â”œâ”€â”€ </span><a href="#req-2-application-needs-to-be-versioned">ğŸ“‹ req #2: Application needs to be versioned</a>
     â”‚   <span class="ascii"> |</span>
     â”‚   <span class="ascii"> â”œâ”€â”€ </span><a href="#option-1-git-tagging">ğŸ‘‰ option #1: git tagging</a>
     â”‚   <span class="ascii"> â””â”€â”€ </span><a href="#option-2-containers-with-tagging">ğŸ‘‰ option #2: containers with tagging</a>
     |   <span class="ascii"></span>
     <span class="ascii">â””â”€â”€ </span><a href="#req-3-4-configurable-deployment-targets">ğŸ“‹ req #3â€“4: Configurable deployment targets</a>
         <span class="ascii"> |</span>
         <span class="ascii"> â”œâ”€â”€ </span><a href="#option-1-config-files">ğŸ‘‰ option #1: config files</a>
         <span class="ascii"> â”œâ”€â”€ </span><a href="#option-2-helm-charts">ğŸ‘‰ option #2: helm charts</a>
         <span class="ascii"> â””â”€â”€ </span><a href="#option-3-branch-based-deployment">ğŸ‘‰ option #3: branch-based deployment</a>
            </pre>
        </div>

        <h2 id="gather-and-understand-requirements">ğŸ” Gather and understand requirements</h2>

        <p>
            Letâ€™s decompose THE PROBLEM a bit:
        </p>

        <ul class="article-list">
            <li>App has to be deployed. It means itâ€™s either a web app, or e.g.
                a backend service like an API. Roger that.</li>
            <li>It should be possible to deploy the app to multiple different environments/targets (like staging,
                production, test, etc.)</li>
            <li>Every environment can run a different version of the appâ€“we need a way to:
                <ul class="article-list">
                    <li style="margin-top: 0.5rem;">configure the env to run a specific version of the app, which
                        induces ğŸ‘‡ğŸ¼</li>
                    <li>version the application itself </li>
                </ul>
            </li>
        </ul>

        <div class="key-concept">
            ğŸš¨ <b>Disclaimer:</b>
            <br>
            <br>
            Here, <i>app</i> may refer to any application youâ€™re building or
            planning to build. It doesnâ€™t really matter what it is in
            particularâ€“what weâ€™re building here will be flexible enough to
            handle multiple different use cases. However, there is one quite
            strong assumption Iâ€™m going to make:
            <br>
            <br>
            <b>There CANâ€™T be multiple versions of the application deployed to a
                single environment at the same time.</b>
        </div>

        <div class="content-separator"></div>

        <p>
            One more thing, not explicitly stated in the aforementioned problem
            definition: when it comes to git flow and branching strategies,
            <b>the project must be easy to maintain</b>. What I mean by that
            contributing to it shouldnâ€™t make devsâ€™ lives too complicated.
        </p>

        <p>
            There must be a main branch to which everything gets merged. Feature
            branches should be used to work on new functionalities, but they
            arenâ€™t allowed to live for too long (max several days). Last but not
            least, devs shouldnâ€™t have to perform multiple merges between
            long-lived branches.
        </p>

        <div class="content-separator"></div>


        <p>
            Okay. Now, letâ€™s gather all of the above into a list of requirements:
        </p>

        <ol class="article-list">
            <li>Git flow must be a no-brainerâ€“we donâ€™t want to deal with
                multiple branches that will have to be frequently synchronized
                with one another.</li>
            <li>Application needs to be versioned.</li>
            <li>It must be possible to deploy a required version of the
                application to the selected deployment environment.</li>
            <li>Every environment runs only one version of the application at the same time.
        </ol>

        <p>
            We could (and maybe even should?) stop here. But I want to challenge
            us even further by introducing one extra requirement:
        </p>

        <ol class="article-list" start="5">
            <li><b>Automate manual processes to a reasonable extent.</b></li>
        </ol>

        <p>
            Donâ€™t be surprised. Remember, youâ€™re reading the <i>too long;
                automated</i> blog!
        </p>

        <figure class="article-internal-gif">
            <img src="https://c.tenor.com/dyOBNrGolfMAAAAd/tenor.gif" alt="Mandark laughing"
                style="width: 100%; height: auto;">
            <figcaption style="text-align: center;">Source: <a
                    href="https://tenor.com/pl/view/mandark-dexter%E2%80%99s-laboratory-laughing-evil-laugh-gif-8584847386607130099">tenor.com</a>
            </figcaption>
        </figure>


        <p>
            List of requirements is a <a
                href="https://www.atlassian.com/agile/project-management/definition-of-done">definition
                of done</a> for the first stage of the process. It is also the input
            for the stage no. 2, which isâ€¦ brainstorming ğŸ¤¯ Warm up your brain,
            buddy.
        </p>

        <p>
            Got any questions so far? Feel free to <a href="mailto:toolongautomated@gmail.com">send me an email</a>,
            Iâ€™ll
            get back to you promptly.
        </p>

        <div class="content-separator"></div>

        <h2 id="brainstorm-solutions">ğŸ§  Brainstorm solutions</h2>

        <h3 id="req-1-no-brainer-git-flow">ğŸ“‹ req #1: No-brainer git flow</h3>

        <p>
            I believe thereâ€™s no one-size-fits-all approach, so letâ€™s explore
            various git branching strategies that could be used in our project.
            Iâ€™ll walk you through three techniques, ordered from the least
            complex to the most complex one.
        </p>

        <h4 id="option-1-pure-trunk-based-development">ğŸ‘‰ğŸ¼ option #1: pure trunk-based development</h4>

        <div class="key-concept">
            <b>Complexity:</b> ğŸ”µ âšª âšª
            <br>
            <b>Versatility:</b> ğŸ”µ âšª âšª
            <br>
            <b>Team size:</b> solo or small team test
        </div>

        <figure class="article-internal-image">
            <img src="2/pure-trunk-based.png" alt="Pure trunk-based git flow" class="zoomable"
                style="width: 100%; height: auto;">
            <figcaption style="text-align: center; padding: 1rem;">
                Pure trunk-based development allows devs to commit directly to
                the main branch (a.k.a. the trunk). Before the commit gets
                accepted, an automated check builds the code and tests it.
                Whenever something fails, the commit is reverted. This ensures
                the trunk never gets broken.
            </figcaption>
        </figure>

        <p>
            Iâ€™d say that in its pure variant (no feature branches at all),
            <a href="https://trunkbaseddevelopment.com/">trunk-based
                development</a> is a bit hardcore. It assumes there exists only a
            single primary branch called main (a.k.a <i>the trunk</i>) that devs
            are supposed to directly push to. No feature branches, no develop
            branches, no release branches, nothing. Just the main branch. Of
            course with some <b>safeguards</b> in place!
        </p>

        <p>
            ğŸ›¡ï¸ <b>Safeguard:</b> Once the commit gets pushed, it automatically
            triggers the build process as part of the continuous integration
            workflow (at least thatâ€™s what should be in place so that
            contributors can sleep peacefully). If it fails, the commit gets
            instantly reverted to ensure the trunk never gets broken.
        </p>

        <p>
            As you can probably guess, pure trunk-based development (no
            additional branches allowed) can work only in small teams of, say,
            three to four devs at max.
        </p>

        <p>
            This approach may be tempting in relatively simple scenarios as it
            really is a no-brainer branching strategy. However, note that it
            doesnâ€™t allow for code reviewing process, and to be honest, this is what
            makes it a no-go for me.
        </p>

        <p>
            Iâ€™m a huge supporter of having the code go through reviews in PRs or
            MRsâ€“these serve multiple purposes like improving code quality, sharing
            good practices across team members, spreading knowledge, and generally
            be on oneâ€™s toes when it comes to understanding whatâ€™s happening in the
            project.
        </p>

        <p>
            Can we do better than having just the trunk that we push directly to,
            but without complicating the development flow too much?
        </p>

        <p>
            Iâ€™m convinced we can.
        </p>

        <h4 id="option-2-permissive-trunk-based-development">ğŸ‘‰ğŸ¼ option #2: permissive trunk-based development</h4>

        <div class="key-concept">
            <b>Complexity:</b> ğŸ”µ ğŸ”µ âšª
            <br>
            <b>Versatility:</b> ğŸ”µ ğŸ”µ âšª
            <br>
            <b>Team size:</b> small or large teams
        </div>

        <figure class="article-internal-image">
            <img src="2/permissive-trunk-based.png" alt="Permissive trunk-based development." class="zoomable"
                style="width: 100%; height: auto;">
            <figcaption style="text-align: center; padding: 1rem;">
                Permissive trunk-based branching strategy uses main as <i>the
                    trunk</i>, but <b>allows for short-lived feature branches</b>.
            </figcaption>
        </figure>

        <p>
            After reading multiple posts and discussions about the trunk-based
            development, I was often left with a feeling of a huge
            misunderstanding among the participants. Letâ€™s look at one of the
            comments that nailed the context:
        </p>

        <figure class="article-internal-image">
            <img src="2/reddit.png" alt="Reddit comment" style="width: 100%; height: auto;" class="zoomable">
            <figcaption style="text-align: center; padding: 1rem;">
                Source: <a
                    href="https://www.reddit.com/r/programming/comments/17vghzn/trunk_based_development_vs_feature_branches/">reddit.com</a>
            </figcaption>
        </figure>

        <p>
            Personally, I tend to agree with what emerges from the discussions
            online:
        </p>

        <div class="key-concept">
            <b>We should avoid having long-lived branches other than trunk.</b>
        </div>

        <p>
            Letâ€™s think of a more permissive trunk-based development flow. Simple,
            functional, but not simplistic: project with the main branch nches (max several days)</b>. It's a no-brainer
            git
            flow (more like <a href="https://docs.github.com/en/get-started/using-github/github-flow">GitHub flow</a>
            than the original <a>git-flow</a>) that will keep
            your branching logic as simple as possible, while allowing for more
            advanced use cases, plus smooth collaboration in larger teams.
        </p>

        <p>
            In this strategy, it is okay to create short-lived feature branches to
            work on new features. Once the feature is ready, a pull request to the
            main branch should be opened. After all discussion threads are
            successfully resolved and optional automated workflows like linters,
            type checks, or unit tests pass, it is fine for the code to be merged.
            Merge can trigger additional steps like docker image building, tagging,
            etc.
        </p>

        <p>
            The main difference here is that it is possible to work on multiple
            features that are developed by larger teams, while still <b>avoiding
                merge hell and a need to synchronize multiple long-lived
                branches</b>.
        </p>

        <p>
            Definitely something worth having a closer look at.
        </p>

        <h4 id="option-3-git-flow">ğŸ‘‰ğŸ¼ option #3: git-flow</h4>

        <div class="key-concept">
            <b>Complexity:</b> ğŸ”µ ğŸ”µ ğŸ”µ
            <br>
            <b>Versatility:</b> ğŸ”µ ğŸ”µ ğŸ”µ
            <br>
            <b>Team size:</b> large teams
        </div>

        <figure class="article-internal-image">
            <img src="2/git-flow.png" alt="Git-flow branching strategy." class="zoomable"
                style="width: 100%; height: auto;">
            <figcaption style="text-align: center; padding: 1rem;">
                git-flow branching strategy leverages multiple branches. Itâ€™s
                versatile, but <b>may become complicated over time</b>.
            </figcaption>
        </figure>

        <p>
            Original git-flow, introduced in 2010 by Vincent Driessen in this <a
                href="https://nvie.com/posts/a-successful-git-branching-model/">article</a>,
            uses multiple branches in its branching strategy: main, develop, and
            supporting branches (feature, release, and hotfix).
        </p>

        <p>
            <b>ğŸš« Complexity:</b> the flow is quite complex as it requires
            frequent branch synchronization. This happens whenever hot fixes are
            introducedâ€“these have to be merged back to both develop and main
            branches.
        </p>

        <div class="key-concept">
            <b>If merging comes with conflicts, this may turn into a
                nightmare.</b>
        </div>

        <p>
            âœ… <b>Versatility:</b> git-flow may come handy if you work in larger
            teams that have strict release requirements. Additionally, release
            branches help maintain multiple versions of the applications
            (including multiple versions deployed to a single environment like
            production). But all comes with a price, here it being the
            complexity.
        </p>

        <p>
            10 years after the first post introducing git-flow, Vincent Driessen
            added a commentary with his reflection on the topic of a git-based
            development:
        </p>

        <div class="key-concept">
            <b><i>[web apps] is not the class of software that I had in mind when I
                    wrote the blog post 10 years ago. If your team is doing continuous
                    delivery of software, I would suggest to adopt a much simpler
                    workflow (like GitHub flow) instead of trying to shoehorn git-flow
                    into your team.</i></b>
            <br>
            <br>
            <i>If, however, you are building software that is explicitly versioned,
                or if you need to support multiple versions of your software in the
                wild, then git-flow may still be as good of a fit to your team as it
                has been to people in the last 10 years.</i>
        </div>

        <div class="content-separator"></div>

        <h3 id="req-2-application-needs-to-be-versioned">ğŸ“‹ req #2: Application needs to be versioned</h3>

        <p>
            There are at least two versioning approaches that come to me
            instantly: tagging specific version of the code using git tags and
            containerizing the application, leveraging container tags to
            distinguish what version of the app is inside the image. There are
            also other solutions like creating versioned packages in languages
            like JS and Python, but Iâ€™d like the tutorial to be as much
            language-agnostic as possible, so Iâ€™m going to exclude packages from
            further analyses.
        </p>

        <h4 id="option-1-git-tagging">ğŸ‘‰ğŸ¼ option #1: git tagging</h4>

        <p>
            Git tagging is simple and reliable. It has several advantages:
        </p>

        <p>
            âœ… Itâ€™s easy to checkout to any version of the code when needed.
        </p>

        <p>
            âœ… Itâ€™s based on git, which is already being used by almost everyone
            in the IT industry. It means using git tags wonâ€™t add any new
            dependency to our project. Nice.
        </p>

        <p>
            Git tagging has one drawback, though:
        </p>

        <div class="key-concept">
            <b>ğŸš« The tag is assigned to all of the code in the repository, not
                just to a single directory with the application.</b>
        </div>

        <p>
            This may not sound like an issue, but imagine your project is a
            monorepo with the source code of multiple applications, each stored
            in a separate subdirectory that should be versioned separately. How
            do you know which app got tagged in that specific git tag you
            checked out?
        </p>

        <p>
            Sure, you could add prefix to the version tag and end up with
            something like app1-0.1.0, app2-1.2.4, etc. The tags would still
            describe the entire code in the monorepo, but you would know which
            app directory to look at based on the tag name. Personally, I find
            this approach useful to a certain degree.
        </p>

        <figure class="article-internal-gif">
            <img src="https://c.tenor.com/sLgNruA4tsgAAAAd/tenor.gif" alt="Warning" style="width: 100%; height: auto">
            <figcaption style="text-align: center;">Source: <a
                    href="https://tenor.com/pl/view/warning-lights-cops-emergency-gif-6098038">tenor.com</a>
            </figcaption>
        </figure>

        <p>
            The aforementioned drawback doesnâ€™t sound harmful at first, but
            thereâ€™s one more perspective I believe I should mention here:
            <b>code isolation</b>.
        </p>

        <p>
            Weâ€™ll soon discuss deployment configuration strategies, but at this
            point itâ€™s important to remember that itâ€™ll be required for the
            deployment platform like VM<sup><a href="#footnote-1" class="footnote-ref" id="footnote-ref-1">1</a></sup>
            or
            Kubernetes<sup><a href="#footnote-2" class="footnote-ref" id="footnote-ref-2">2</a></sup> to run the
            selected
            version of the
            application. Using solely git tagging mechanism requires checking out to
            a specific tag, meaning <b>the whole repository will be checked out</b>.
        </p>

        <div class="key-concept">
            ğŸ™…ğŸ»â€â™‚ï¸ğŸ™…ğŸ»â€â™‚ï¸ <b>I wouldnâ€™t do it, neither in monorepo, nor in the
                one-repo-per-app case.</b>
        </div>

        <p>
            Why?
        </p>

        <p>
            Because I donâ€™t want app2 deployment to include any code that is not
            strictly required by this app to run. I donâ€™t want app1â€™s source
            code to be there. Not to mention the utilities like readmes,
            changelogs, etc.
        </p>

        <p>
            Plus, it is simply dangerousâ€“it potentially exposes entire codebase
            of the project if <b>any deployment gets hacked</b>.
        </p>

        <figure class="article-internal-gif">
            <img src="https://c.tenor.com/mqBYbQHsqUcAAAAd/tenor.gif" alt="Phew" style="width: 100%; height: auto;">
            <figcaption style="text-align: center;">
                Source: <a href="https://tenor.com/pl/view/phew-dogs-gif-10241261">tenor.com</a>
            </figcaption>
        </figure>

        <p>
            Okay, I hope you now understand that we need an approach that will
            allow us to <b>deploy only the code used by the application</b> when
            deploying its specific version.
        </p>

        <p>
            Containers come really handy in such situations.
        </p>

        <h4 id="option-2-containers-with-tagging">ğŸ‘‰ğŸ¼ option #2: containers with tagging</h4>

        <p>
            There are so many benefits of containerizing the app that itâ€™s hard to
            list them all:
        </p>

        <p>
            âœ… isolating code into a self-contained entity
        </p>

        <p>
            âœ… tagging images enables versioning of their content
        </p>

        <p>
            âœ… encouraging good dev practices
        </p>

        <p>
            âœ… reducing the risk of the famous "works for me" situation<sup><a href="#footnote-3" class="footnote-ref"
                    id="footnote-ref-3">3</a></sup>
        </p>

        <p>
            âœ… anything that supports containers can be used as the deployment
            platform
        </p>

        <p>
            Introducing the concept of containerization to your project will
            increase its complexity a bit, but itâ€™s worth every additional
            second invested.
        </p>

        <p>
            Why?
        </p>

        <p>
            Well, I think itâ€™s mostly because it <b>requires the developer to
                make a dump of the environment configuration</b> that is needed to
            run the app in a form of e.g. a Dockerfile. Providing Dockerfile
            alone serves as an invaluable piece of documentation, and since I
            strongly believe in the self-documenting code, Iâ€™d recommend doing
            this.
        </p>

        <div class="content-separator"></div>

        <h3 id="req-3-4-configurable-deployment-targets">ğŸ“‹ req #3-4: Configurable deployment targets</h3>

        <p>
            Thereâ€™s one thing we need to keep in mind here: our configuration
            method must make it possible to specify one app version per
            deployment environment. Nothing less, nothing more.
        </p>

        <h4 id="option-1-config-files">ğŸ‘‰ğŸ¼ option #1: config files</h4>

        <p>
            One of the most popular ways to configure stuff is to use
            configuration files. Shocker.
        </p>

        <figure class="article-internal-gif">
            <img src="https://c.tenor.com/UZJd1pjj4NMAAAAd/tenor.gif" alt="Shocker" style="width: 100%; height: auto;">
            <figcaption style="text-align: center;">
                Source: <a
                    href="https://tenor.com/pl/view/surprised-pikachu-pokemon-shock-surprised-pikachu-gif-15357817">tenor.com</a>
            </figcaption>
        </figure>

        <p>
            Jokes aside, configuration files are a remarkably simple, yet
            powerful solution to this problem. I can easily imagine a directory
            in your project called config that would have a subdirectory called
            after every deployment target you have. In these subdirectories, you
            could put a simple .env/YAML/whatever-format-you-choose file (one
            per env) that would have every required variable defined in it. If
            these files were to store secrets, they could simply be encrypted
            with something like sops and be decrypted on the fly during the
            CI/CD process.
        </p>

        <p>
            Hereâ€™s what the configuration directory tree could look like:
        </p>

        <pre>
            <code class="language-plaintext">
config/
â”œâ”€â”€ production/
â”‚   â””â”€â”€ .env
â”œâ”€â”€ staging/
â”‚   â””â”€â”€ .env
â””â”€â”€ test/
    â””â”€â”€ .env
            </code>
        </pre>
        <br>

        <h4 id="option-2-helm-charts">ğŸ‘‰ğŸ¼ option #2: helm charts</h4>

        <p>
            <a href="https://helm.sh/">Helm</a> is a package manager for
            Kubernetes. It lets you create, version, and publish your
            <b>Kubernetes</b> applications in a flexible, standardized format.
        </p>

        <p>
            Itâ€™s pretty dope, but choosing helm requires us to assume that the
            deployment platform for our application will be solely Kubernetes,
            <b>which is not necessarily true</b>.
        </p>

        <p>
            This is why Iâ€™m going to exclude it from our brainstorming session.
        </p>

        <h4 id="option-3-branch-based-deployment">ğŸ‘‰ğŸ¼ option #3: branch-based deployment</h4>

        <p>
            In branch-based deployment, <b>deployment targets are associated
                with specific branches</b> â€“ whenever changes get pushed, a single
            environment is updated by its dedicated CI/CD workflow. Simple.
        </p>

        <p>
            There still needs to be a mechanism that would allow us to use
            different variable values per each deployment target, though. There
            are at least several ways to achieve this, one of them being <a
                href="https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment">GitHub
                Environments</a> or something similar. It lets you define a set of
            variables/secrets that are assigned to a specific deployment
            environment. CI/CD workflow then uses environmental variables that
            are substituted with secretsâ€™ values from the suitable deployment
            target.
        </p>

        <p>
            Env-specific secrets could also be stored in cloud secrets managers
            like <a href="https://aws.amazon.com/secrets-manager/">AWS Secrets
                Manager</a> or Google Cloudâ€™s <a
                href="https://cloud.google.com/security/products/security-key-management?hl=pl">KMS</a>.
            The way they work is virtually identical, yet requires additional
            configuration and permissions to connect to the cloud environment
            and retrieve required values from there.
        </p>

        <p>
            Thereâ€™s one more way to achieve env-specific configuration: <b>having
                separate CI/CD workflows defined for every deployment target</b>.
            Drawback here is that this approach may require quite a lot of
            copy-pasting and extra maintenance efforts when the same part of the
            workflow needs to be updated across multiple targets. The advantage,
            on the other hand, is that it doesnâ€™t necessarily require us to have
            per-env branch in the repository, which is nice.
        </p>

        <div class="content-separator"></div>

        <p>
            Wow, it must have taken a while to go through all of the content above,
            buddy.
        </p>

        <p>
            Congratulations! ğŸ™ŒğŸ¼
        </p>

        <figure class="article-internal-gif">
            <img src="https://c.tenor.com/029LgfMnsisAAAAd/tenor.gif" alt="Congratulations"
                style="width: 100%; height: auto;">
            <figcaption style="text-align: center;">
                Source: <a href="https://tenor.com/pl/view/applause-leonardo-dicaprio-clap-gif-9602869">tenor.com</a>
            </figcaption>
        </figure>

        <p>
            In the next post, Iâ€™ll guide you through the scoping stage to select
            one option for every requirement from our list. Then, weâ€™ll dive
            into the implementation and testing. And then, weâ€™ll stop.
        </p>

        <p>
            If you have any thoughts/suggestions youâ€™d like to share, send me an
            email at <a href="mailto:toolongautomated@gmail.com">toolongautomated@gmail.com</a>.
        </p>

        <p>
            Thanks, buddy.
        </p>

        <p>
            Stay tuned! ğŸ™ŒğŸ¼
        </p>

        <div class="footnotes">
            <h2>Footnotes</h2>
            <ol style="list-style-type: none;">
                <li id="footnote-1"><a href="#footnote-ref-1">â†ª 1</a> e.g. Compute Engine in GCP or EC2 in AWS</li>
                <li id="footnote-2"><a href="#footnote-ref-2">â†ª 2</a> e.g. GKE in GCP or EKS in AWS</li>
                <li id="footnote-3"><a href="#footnote-ref-3">â†ª 3</a> Although the introduction of ARM-based docker
                    images reintroduced this fear: some external dependencies like Python libraries may not be
                    arm-compatible yet.</li>
            </ol>
        </div>

        <div class="article-navigation">
            <div class="nav-buttons">
                <a href="automation-unbound.html" class="nav-button prev-article">
                    <div class="nav-button-content">
                        <div class="nav-text">
                            <div class="nav-direction">â† previous article</div>
                            <div class="nav-title">automation unbound</div>
                        </div>
                        <img src="1/image.png" alt="automation unbound" class="nav-thumbnail">
                    </div>
                </a>
                <!-- <a href="one-branch-to-rule-them-all-2.html" class="nav-button next-article">
                    <div class="nav-button-content">
                        <div class="nav-text">
                            <div class="nav-direction">next article â†’</div>
                            <div class="nav-title">one branch to rule them all | guided series #2</div>
                        </div>
                        <img src="3/image.png" alt="Part 2" class="nav-thumbnail">
                    </div>
                </a> -->
            </div>
        </div>

    </main>

    <footer>
        <div class="footer-grid">
            <div class="footer-column">
                <h3>too long; automated</h3>
                <p class="footer-description">Exploring digital world to automate it and enjoy life. Written by Bartosz
                    Miselis</p>
                <br>
                <a href="mailto:toolongautomated@gmail.com">toolongautomated@gmail.com</a>
            </div>
            <div class="footer-column">
                <div class="footer-social">
                    <div class="social-item">
                        <img src="../../assets/github.svg" alt="GitHub" class="social-icon">
                        <a href="https://github.com/toolongautomated" class="social-handle">toolongautomated</a>
                    </div>
                    <div class="social-item">
                        <img src="../../assets/x.svg" alt="X" class="social-icon">
                        <a href="https://x.com/bmiselis" class="social-handle">bmiselis</a>
                    </div>
                    <div class="social-item">
                        <img src="../../assets/linkedin.svg" alt="LinkedIn" class="social-icon">
                        <a href="https://www.linkedin.com/in/bmiselis/" class="social-handle">bmiselis</a>
                    </div>
                    <div class="social-item">
                        <img src="../../assets/youtube.svg" alt="YouTube" class="social-icon">
                        <a href="https://www.youtube.com/@toolongautomated" class="social-handle">toolongautomated</a>
                    </div>
                </div>
            </div>
        </div>
    </footer>
    <div id="zoom-overlay" class="zoom-overlay">
        <img id="zoomed-img" class="zoomed-image">
    </div>
    <script src="../../scripts/theme.js"></script>
    <script src="../../scripts/zoomable.js"></script>
    <script src="../../scripts/interactions.js"></script>
    <script src="../../highlight/highlight.min.js"></script>
    <script src="../../scripts/progressbar.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>

</html>